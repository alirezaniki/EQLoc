#!/bin/bash

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Config
VM_Name="IRSC_Vel"		# Velocity model name
Dept_Prob="True"		# Search for optimal depth? (True/False)
initDP="10"				# Initial Depth to explor the epicenter (km)
Depth1="8"				# Upper depth limit to search for the best depth (km)
Depth2="12"				# Lower depth limit to search for the best depth (km)
Depth_I="1"				# Depth intervals in depth optimization (km)
SAC="sac"				# Sac-data input-file extension (SAC/sac)
S12_TD="10"			# This value is subtracted/added from/to the actual time differece
						# of P arrivals in the first and second closest stations to define
						# an interval for the same criteria in all grid points to restrict
						# them from and boost the process.
						
PnPg_Th="190"			# Distance in km to declare between Pg and Pn
Init_Grid_In="1.0"		# Initial Grid Intervals (deg)
Radius="2.0"			# Search Radius (deg)
N_Iter="2"				# Number of grid search Iterations over the best 
						# grid point to maximize the location accuracy.							
										
AutoPick="True"			# Either to use Auto_Pick procedure or not (True/False)
LTA_P="30"				# LTA Window Length for P phase Picking
STA_P="03"				# STA Window Length for P phase Picking
P_WTh="5"				# STA/LTA Threshold for P phase-picking triggering
Inc="01"				# Sliding Increament, Seconds
WTh_I="0.5"				# STA/LTA Threshold subtraction value in Reprocessing (in case no phase picked at the first round)
Min_WTh_Th="2.5"		# Minimum acceptable P_WTh Threshold in Reprocessing
Method="Class_LR"		# Sliding Method (Class_LR / Class_RR)

#~~~~~~~~~~~~~~ Actual location of EQ (Only for GMT plot)
EVELAT="28.25"
EVELON="57.92"

##### SAC Config
F1_P=1.0				# Band-Pass Filter lower corner
F2_P=5.0				# Band-Pass Filter upper corner


#  Class_RR:	<=====================> LTA
#								<=====> STA	
#  Class_LR:	<=====================> LTA
#				    				<=====> STA

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ bODY sCript (Do not ChAnge)

Home=`dirname $(readlink -f "$0")`
input="$Home/Input"	
VelModel="$Home/$VM_Name"	


round ()
{
echo $(printf %.$2f $(echo "scale=$2;(((10^$2)*$1)+0.5)/(10^$2)" | bc))
}

deg2rad ()
{
	echo "scale=3; $1 * 0.01745329" | bc -l	
}

rad2deg ()
{
	echo "scale=3; $1 * 57.2957795" | bc -l 
}

time2sec ()
{
	sec=`date '+%s' --date="$1"`
	msc=`date '+%N' --date="$1"`
	echo "scale=2; $sec + ($msc / 1000000000)" | bc -l
}

Absolute ()
{
	echo "scale=1; sqrt ($1 * $1)" | bc -l
}	

distance ()
{
	stlat=`deg2rad $1`
	stlon=`deg2rad $2`
	evela=`deg2rad $3`
	evelo=`deg2rad $4`
	lodif=`echo "$stlon - $evelo" | bc -l`
	
	DI=`echo "s ($evela) * s ($stlat) + c ($evela) * c ($stlat) * c ($lodif)" | bc -l`
	aD=`echo "3.14159 / 2 - a ($DI / sqrt (1 - $DI * $DI ))" | bc -l` && deg_aD=`rad2deg $aD`
	Dist=`echo "scale=2; $deg_aD * 60 * 1.15078 * 1.609344" | bc -l`
	echo `round $Dist 2`
}

Data_Pre_Pro ()
{
	python - <<- EOF
		import warnings
		import glob

		with warnings.catch_warnings ():	
		    warnings.filterwarnings("ignore")
		    from obspy import read, Trace, Stream, signal
				
		for data in glob.glob ('*$SAC'):
		    st = read (data)	
		    data = st[0].data
		    stat = st[0].stats.station
		    netw = st[0].stats.network
		    chan = st[0].stats.channel

		    st_filt = st.copy()		
		    st_filt.filter ('highpass', freq=$F1_P, corners=3, zerophase=True)
		    st_filt.filter ('lowpass', freq=$F2_P, corners=3, zerophase=True)
		    st_filt.detrend ("spline", order=3, dspline=500)
			
		    envelope_points = signal.filter.envelope (st_filt[0].data)

		    out_trace = Stream ([Trace (data = envelope_points, header=st[0].stats)])
		    output_name = f'envelope.{stat}.{netw}.{chan}.$SAC'
		    out_trace.write (output_name, format="SAC", encoding=5)		
		
	EOF
}

GET_RMS_P ()
{
	CMD="r $data \n MTW $1 $2; RMS TO USER0 \n MTW $3 $4; RMS TO USER1 \n setbb RL &1,USER0 RS &1,USER1 \n getbb TO .tmp NAMES off RL RS \n q \n"
	echo -e "$CMD" | sac 2> /dev/null 1>&2
}

Cleaner ()
{
	cd $input  
	[[ `ls $input/*SAC 2> /dev/null` ]] && SAC="SAC" || SAC="sac"
	ls -I "*$SAC" | xargs rm -f
	rm envelope* 2> /dev/null
}

P_Picker_Body ()
{
	bgtm=`saclst B f $data | awk '{print $2}'` && bgtm=`printf "%0.f\n" $bgtm`
	entm=`saclst E f $data | awk '{print $2}'` && entm=`printf "%0.f\n" $entm`
	evtm=`saclst KZTIME f $data | awk '{print $2}'` 
	stnm=`saclst KSTNM f $data | awk '{print $2}'` 

	L1="$bgtm"
	L2=`echo "$L1 + $LTA_P" | bc -l`

	while (( `echo "$L2 <= ($entm * 2 / 3)" | bc -l` )); do	
		if [[ "$Method" = "Class_RR" ]]; then
			S1=`echo "$L2 - $STA_P" | bc -l`
			S2="$L2"
		elif [[ "$Method" = "Class_LR" ]]; then
			S1=`echo "$L2 - ($STA_P / 3)" | bc -l`
			S2=`echo "$L2 + ($STA_P * 2 / 3)" | bc -l`	
		else
			echo "Please select a proper method" && exit
		fi		
		
		GET_RMS_P $L1 $L2 $S1 $S2
		
		RMS_L=`awk 'NR==1 {print $0}' .tmp` 
		RMS_S=`awk 'NR==2 {print $0}' .tmp` 
		C=`echo "scale=1; ($RMS_S / $RMS_L) >= $P_WTh" | bc -l`
		
		if [[ "$C" = "1" ]]; then
			echo -e "RMS_S = $RMS_S RMS_L = $RMS_L `echo "scale=1; $RMS_S / $RMS_L" | bc -l`"
			PSec=`echo "scale=1; ($S1 + $S2) / 2" | bc -l` 
			Ptme=`date --date "$evtm UTC +$PSec sec" "+%H:%M:%S"`
			echo -e "r $data \n ch a $PSec \n wh \n w over \n q \n" | sac 2> /dev/null 1>&2
			echo "$data $PSec $Ptme $stnm" >> P_Arrivals.dat && break
		fi	
		cat /dev/null > .tmp
		L1=`echo "$L1 + $Inc" | bc -l`
		L2=`echo "$L2 + $Inc" | bc -l`		
	done
}

P_Picker ()
{
	cd $input
	Data_Pre_Pro
		
	for data in `ls envelope*`; do
		echo -e "# Working on\n$data (Picking P phase)"
		cat /dev/null > .tmp
		P_Picker_Body
	done

	Or_WTh="$P_WTh"
	for data in `ls envelope*`; do
		if [[ ! `grep $data P_Arrivals.dat 2> /dev/null` ]]; then
			echo -e "# Reprocessing data:\n$data (Picking P phase)"
			while [[ ! `grep $data P_Arrivals.dat 2> /dev/null` ]]; do
				P_WTh=`echo "$P_WTh - $WTh_I" | bc -l` && (( `echo "$P_WTh < $Min_WTh_Th" | bc -l` )) && break
				P_Picker_Body
			done
		fi
		P_WTh="$Or_WTh"
	done
}

grid ()
{
	cat /dev/null > Grids.dat
	GrdMinLat=`echo "scale=0; $Nearest_Lat - $Radius" | bc -l`
	GrdMaxLat=`echo "scale=0; $Nearest_Lat + $Radius" | bc -l`
	GrdMinLon=`echo "scale=0; $Nearest_Lon - $Radius" | bc -l`
	GrdMaxLon=`echo "scale=0; $Nearest_Lon + $Radius" | bc -l`
	
	for Glat in $(seq "$GrdMinLat" "$Init_Grid_In" "$GrdMaxLat"); do
		for Glon in $(seq "$GrdMinLon" "$Init_Grid_In" "$GrdMaxLon"); do
			echo "$Glat $Glon" >> Grids.dat
		done	
	done	
	cat Grids.dat >> All_Grds.dat
}

map ()
{
	GrdMinLon=`sort -n -k 2 $input/Grids.dat | head -1 | cut -f 2 -d " "`
	GrdMaxLon=`sort -n -k 2 $input/Grids.dat | tail -1 | cut -f 2 -d " "`
	GrdMinLat=`sort -n -k 1 $input/Grids.dat | head -1 | cut -f 1 -d " "`
	GrdMaxLat=`sort -n -k 1 $input/Grids.dat | tail -1 | cut -f 1 -d " "`
	StaMinLon=`sort -n -k 3 $input/stations.used | head -1 | cut -f 3 -d " "`
	StaMaxLon=`sort -n -k 3 $input/stations.used | tail -1 | cut -f 3 -d " "`
	StaMinLat=`sort -n -k 2 $input/stations.used | head -1 | cut -f 2 -d " "`
	StaMaxLat=`sort -n -k 2 $input/stations.used | tail -1 | cut -f 2 -d " "`
	(( `echo "$GrdMinLon <= $StaMinLon" | bc -l` ))	&& MapMinLon="$GrdMinLon" || MapMinLon="$StaMinLon"
	(( `echo "$GrdMaxLon >= $StaMaxLon" | bc -l` ))	&& MapMaxLon="$GrdMaxLon" || MapMaxLon="$StaMaxLon"
	(( `echo "$GrdMinLat <= $StaMinLat" | bc -l` ))	&& MapMinLat="$GrdMinLat" || MapMinLat="$StaMinLat"
	(( `echo "$GrdMaxLat >= $StaMaxLat" | bc -l` ))	&& MapMaxLat="$GrdMaxLat" || MapMaxLat="$StaMaxLat"	
	(( `echo "$EVELAT <= $MapMinLat" | bc -l` )) && MapMinLat=`echo "$EVELAT - 0.75" | bc -l`
	(( `echo "$EVELAT >= $MapMaxLat" | bc -l` )) && MapMaxLat=`echo "$EVELAT + 0.75" | bc -l`
	(( `echo "$EVELON <= $MapMinLon" | bc -l` )) && MapMinLon=`echo "$EVELON - 0.75" | bc -l`
	(( `echo "$EVELON >= $MapMaxLon" | bc -l` )) && MapMaxLon=`echo "$EVELON + 0.75" | bc -l`
	
	Lo1=`echo "$MapMinLon - 0.5" | bc -l`
	Lo2=`echo "$MapMaxLon + 0.5" | bc -l`
	La1=`echo "$MapMinLat - 0.5" | bc -l`
	La2=`echo "$MapMaxLat + 0.5" | bc -l`
	
	gmt pscoast -R$Lo1/$Lo2/$La1/$La2 -JM4i -Sgray -Xc -Yc -Gwhite -Ba -BWSen -K > Map.ps
	gmt psxy -R -J All_Grds.dat -Sc0.055c -Gblack -i1,0 -K -O >> Map.ps
	echo "$EVELON $EVELAT" | gmt psxy -R -J -Sa0.25 -Gred -i0,1 -K -O >> Map.ps
	gmt psxy -R -J stations.used -St0.25c -Gblack -i2,1 -K -O >> Map.ps
	cat Epicenter.dat | head -1 | gmt psxy -R -J -Sc0.25 -Gred -i1,0 -K -O >> Map.ps
	echo -e "\nFinal Earthquake Location:\n"	
	cat $input/Epicenter.dat	
}

vel_Reader ()
{
	cat /dev/null > $Home/Velmodel.tvel
	sed -i '/^$/d' $VelModel
	read -a DP <<< `awk 'NR > 1 {print $1}' $VelModel | tr '\n' ' '`
	read -a VP <<< `awk 'NR > 1 {print $2}' $VelModel | tr '\n' ' '`
	read -a VS <<< `awk 'NR > 1 {print $3}' $VelModel | tr '\n' ' '`
	read -a DN <<< `awk 'NR > 1 {print $4}' $VelModel | tr '\n' ' '`
	
	echo -e "# Header Line\n# Header Line\n${DP[0]}  ${VP[0]}   ${VS[0]}   ${DN[0]}" > $Home/Velmodel.tvel
	for ((i=1; i<${#DP[@]}; i++)); do
		[[ -z ${DP[$i]} ]] || [[ -z ${VP[$i]} ]] || [[ -z ${VS[$i]} ]] && echo "Incomplete Velocity model!" && exit
		echo "${DP[$i]}  ${VP[$((i-1))]}   ${VS[$((i-1))]}   ${DN[$((i-1))]}" >> $Home/Velmodel.tvel
		echo "${DP[$i]}  ${VP[$i]}   ${VS[$i]}   ${DN[$i]}" >> $Home/Velmodel.tvel
	done
}

Regression ()
{
	x=`awk '{print $3}' $1 | tr '\n' ', '`
	y=`awk '{print $4}' $1 | tr '\n' ', '`
	
	python - <<- END
		from scipy import stats
		import numpy as np
		X = np.array ([$x])
		Y = np.array ([$y])
		slope, intercept, r, _, _ = stats.linregress(X, Y)
		print (r**2)
	END
}

Real_Regression ()
{
	export Closest_Inf=`sort -k 3 $input/P_Arrivals.dat | head -1`
	export SecondC_Inf=`sort -k 3 $input/P_Arrivals.dat | head -2 | tail -1`
	export Closest_Sta=`echo $Closest_Inf | awk '{print $NF}'`
	export SecondC_Sta=`echo $SecondC_Inf | awk '{print $NF}'`
	export Closest_Tme=`echo $Closest_Inf | awk '{print $3}'`
	export SecondC_Tme=`echo $SecondC_Inf | awk '{print $3}'`
	export Closest_TmS=`time2sec $Closest_Tme`
	export SecondC_TmS=`time2sec $SecondC_Tme`
	export Closest_Lat=`grep -w "$Closest_Sta" $Home/stations.dat | awk '{print $2}'`
	export Closest_Lon=`grep -w "$Closest_Sta" $Home/stations.dat | awk '{print $3}'`
	export SecondC_Lat=`grep -w "$SecondC_Sta" $Home/stations.dat | awk '{print $2}'`
	export SecondC_Lon=`grep -w "$SecondC_Sta" $Home/stations.dat | awk '{print $3}'`
	[[ -z "$Closest_Lat" ]] || [[ -z "$Closest_Lon" ]] && echo "No information found for The closest station!" && exit
	[[ -z "$SecondC_Lat" ]] || [[ -z "$SecondC_Lon" ]] && echo "No information found for The second closest station!" && exit
	cat $input/P_Arrivals.dat | sort -k 3 | while read info; do
		stname=`echo $info | awk '{print $NF}'`	
		[[ "$stname" = "$Closest_Sta" ]] && continue
		stlat=`grep -w "$stname" $Home/stations.dat | awk '{print $2}'`
		stlon=`grep -w "$stname" $Home/stations.dat | awk '{print $3}'`	
		[[ -z "$stlat" ]] || [[ -z "$stlon" ]] && continue
		dist=`distance $stlat $stlon $Closest_Lat $Closest_Lon`		
		sttime=`echo $info | awk '{print $3}'`
		sttimS=`time2sec $sttime`
		Tdiff=`echo "$sttimS - $Closest_TmS" | bc -l`
		echo "$Closest_Sta $stname $dist $Tdiff"
	done > dist_time.dat
	export Real_Slope=`Regression dist_time.dat`
}

Ttime ()
{
	python2 - <<- EOF
		from pyrocko import cake
		import numpy as np
		km = 1000.
		
		model = cake.load_model('$Home/Velmodel.tvel')
		source_depth = $Dep * km
		distance = np.array ([$1])* km * cake.m2d
		Phase = cake.PhaseDef ('$phase')
		for arrival in model.arrivals (distance, phases=Phase, zstart=source_depth):
		    print '%13g %13g' % (arrival.x*cake.d2m/km, arrival.t)
	EOF
}    

Grid_Search ()
{
	cat Grids.dat | while read Ginfo; do
		Glat=`echo $Ginfo | awk '{print $1}'` && evela="$Glat"
		Glon=`echo $Ginfo | awk '{print $2}'` && evelo="$Glon"
		echo "Processing Grid point << Lat $Glat Lon $Glon >>"
		
		cat /dev/null > $Glon-$Glat.dat
		cat /dev/null > dist_tmp
		cat /dev/null > traveltimes.dat
		
		mindist=`distance $Closest_Lat $Closest_Lon $evela $evelo`
		dislimt=`echo "scale=2; $mindist - ($Init_Grid_In / 2 * 113)" | bc -l`	# deg ~ 113 km
		echo "Minimum allowed epicentral distance for the closest station is $dislimt." >> $Glon-$Glat.dat
		
		# Condition 1 (time difference)
		timedif=`grep -w "$Closest_Sta $SecondC_Sta" dist_time.dat | cut -f 4 -d " "`
		t1=`echo "$timedif - $S12_TD" | bc -l`
		t2=`echo "$timedif + $S12_TD" | bc -l`
		echo "Time difference interval between $Closest_Sta and $SecondC_Sta must be $t1 to $t2 sec." >> $Glon-$Glat.dat
		Dep="$initDP"
		dist1="$mindist"
		dist2=`distance $SecondC_Lat $SecondC_Lon $evela $evelo`
		(( `echo "$dist1 < $PnPg_Th" | bc -l` )) && phase="p" || phase="P"
		T1=`Ttime $dist1  2> /dev/null` && T1=`echo $T1 | awk '{print $2}'`	
		if [[ -z "$T1" ]]; then 
			[[ "$phase" = "p" ]] && phase="P" || phase="p"
			T1=`Ttime $dist1 2> /dev/null` && T1=`echo $T1 | awk '{print $2}'`	
		fi
		(( `echo "$dist2 < $PnPg_Th" | bc -l` )) && phase="p" || phase="P"
		T2=`Ttime $dist2 2> /dev/null` && T2=`echo $T2 | awk '{print $2}'`	
		if [[ -z "$T2" ]]; then 
			[[ "$phase" = "p" ]] && phase="P" || phase="p"
			T2=`Ttime $dist2 2> /dev/null` && T2=`echo $T2 | awk '{print $2}'`	
		fi		
		if [[ -n "$T1" ]] && [[ -n "$T2" ]]; then
			DF=`echo "$T2 - $T1" | bc -l`
			echo "$Closest_Sta = $T1 s, $SecondC_Sta = $T2 s, Diff = $DF s" >> $Glon-$Glat.dat
			(( `echo "$DF < $t1" | bc -l` )) || (( `echo "$DF > $t2" | bc -l` )) && echo "Time criteria is not passed." >> $Glon-$Glat.dat && continue	
		else
			echo "insufficient travel time info for the closest stations, skipping the grid point .." >> $Glon-$Glat.dat && continue	
		fi
		
		cat stations.used | while read Sinfo; do
			stnam=`echo $Sinfo | awk '{print $1}'` 
			stlat=`echo $Sinfo | awk '{print $2}'` 
			stlon=`echo $Sinfo | awk '{print $3}'` 
			dist=`distance $stlat $stlon $evela $evelo`
			(( `echo "$dist < $dislimt" | bc -l` )) && echo "$stnam, $dist < $dislimt" >> $Glon-$Glat.dat && cat /dev/null > dist_tmp && break 
			echo "$stnam $dist" >> dist_tmp
		done 
		[[ ! -s dist_tmp ]] && continue
		
		cat stations.used | while read Sinfo; do
			stnam=`echo $Sinfo | awk '{print $1}'`	
			dist=`grep -w "$stnam" dist_tmp | cut -f 2 -d " "` 
			(( `echo "$dist < $PnPg_Th" | bc -l` )) && phase="p" || phase="P"
			TT=`Ttime $dist 2> /dev/null` && TTm=`echo $TT | awk '{print $2}'`	
			if [[ -z "$TTm" ]]; then 
				[[ "$phase" = "p" ]] && phase="P" || phase="p"
				TT=`Ttime $dist 2> /dev/null` && TTm=`echo $TT | awk '{print $2}'`	 
			fi
			echo "distance to $stnam = $dist km, P_ttime = $TTm" >> $Glon-$Glat.dat
			echo "$stnam $TTm" >> traveltimes.dat
		done 		
		[[ ! -s traveltimes.dat ]] && echo "No synthetic travel-time calculated for grid point: $evela, $evelo. Skipped ..." && continue

		closest_st_ttime=`grep -w "$Closest_Sta" traveltimes.dat | cut -f 2 -d " "`
		[[ -z "$closest_st_ttime" ]] && echo "No synthetic T-time calculated for the actual nearest station (Grid: $evela, $evelo). Skipped ..." && continue
		
		cat traveltimes.dat | while read info; do
			stname=`echo $info | awk '{print $1}'`
			[[ "$stname" = "$Closest_Sta" ]] && continue
			sttime=`echo $info | awk '{print $2}'`
			diff=`echo "$sttime - $closest_st_ttime" | bc -l`
			dist=`grep -w "$stname" $input/dist_time.dat | cut -f 3 -d " "`
			echo "$Closest_Sta $stname $dist $diff"
		done > synt_tdiffs.dat	
			
		Syn_Slope=`Regression synt_tdiffs.dat`
		Slope_Diff=`echo "scale=6; $Real_Slope - $Syn_Slope" | bc -l` && Slope_Diff=`Absolute $Slope_Diff`
		echo "Misfit = $Slope_Diff" 
		echo "Misfit = $Slope_Diff" >> $Glon-$Glat.dat
		echo "$Glat $Glon $Slope_Diff" >> RMS.dat
	done	
	sort -n -k 3 $input/RMS.dat 2> /dev/null | head -1 > $input/Epicenter.dat	
	[[ ! -s $input/Epicenter.dat ]] && echo -e "Program Failed to Locate the Epicenter\nA more dense grid may be helpful." && exit 1

}

TT_Calculator ()
{
	cat $input/P_Arrivals.dat | while read info; do
		stnm=`echo $info | awk '{print $NF}'`
		stla=`grep -w "$stnm" $Home/stations.dat | awk '{print $2}'`
		stlo=`grep -w "$stnm" $Home/stations.dat | awk '{print $3}'`
		[[ -z "$stla" ]] || [[ -z "$stlo" ]] && continue
		echo "$stnm $stla $stlo"
	done > stations.used		
	
	Nearest_Lat="$Closest_Lat"
	Nearest_Lon="$Closest_Lon"			
	grid
	Dep="$initDP"
	Grid_Search
	
	N_Iter=${N_Iter%.*}
	while [[ "$N_Iter" -gt "0" ]]; do
		cat /dev/null > RMS.dat
		Nearest_Lat=`cut -f 1 -d " " Epicenter.dat`
		Nearest_Lon=`cut -f 2 -d " " Epicenter.dat`
		Radius=`echo "scale=1; $Radius / 2" | bc -l`
		Init_Grid_In=`echo "scale=1; $Init_Grid_In / 2" | bc -l`
		grid 
		Grid_Search
		N_Iter=$((N_Iter - 1))
	done	
}

Depth_BT ()
{
	evela=`awk 'NR==1 {print $1}' Epicenter.dat`
	evelo=`awk 'NR==1 {print $2}' Epicenter.dat`
	echo "Let's Probe the Depth ... "
	for Dep in $(seq "$Depth1" "$Depth_I" "$Depth2"); do
		echo "Assessing Depth $Dep posibility ..."	
		cat stations.used | while read Sinfo; do
			stnam=`echo $Sinfo | awk '{print $1}'`
			stlat=`echo $Sinfo | awk '{print $2}'` 
			stlon=`echo $Sinfo | awk '{print $3}'` 				
			dist=`distance $stlat $stlon $evela $evelo` 
			(( `echo "$dist < $PnPg_Th" | bc -l` )) && phase="p" || phase="P"
			TT=`Ttime $dist 2> /dev/null` && TTm=`echo $TT | awk '{print $2}'`
			if [[ -z "$TTm" ]]; then 
				[[ "$phase" = "p" ]] && phase="P" || phase="p"
				TT=`Ttime $dist 2> /dev/null` && TTm=`echo $TT | awk '{print $2}'`
			fi
			echo "$stnam $TTm" 
		done > traveltimes.dat	
		[[ ! -s traveltimes.dat ]] && echo "No synthetic travel-time calculated for Depth = $Dep. Skipped ..." && continue

		closest_st_ttime=`grep -w "$Closest_Sta" traveltimes.dat | cut -f 2 -d " "`
		[[ -z "$closest_st_ttime" ]] && echo "No synthetic T-time calculated for the actual nearest station in Depth: $Dep. Skipped ..." && continue
		
		cat traveltimes.dat | while read info; do
			stname=`echo $info | awk '{print $1}'`
			[[ "$stname" = "$Closest_Sta" ]] && continue
			sttime=`echo $info | awk '{print $2}'`
			diff=`echo "$sttime - $closest_st_ttime" | bc -l`
			dist=`grep -w "$stname" $input/dist_time.dat | cut -f 3 -d " "`
			echo "$Closest_Sta $stname $dist $diff"
		done > synt_tdiffs.dat	
			
		Syn_Slope=`Regression synt_tdiffs.dat`
		Slope_Diff=`echo "scale=5; $Syn_Slope - $Real_Slope" | bc -l` && Slope_Diff=`Absolute $Slope_Diff`
		echo "$Dep $Slope_Diff" >> Dep_RMS.dat
	done	
	echo Depth `sort -n -k 2 $input/Dep_RMS.dat 2> /dev/null | cut -f 1 -d " " | head -1` >> $input/Epicenter.dat	

}


Cleaner
[[ ! `ls $input/*$SAC 2> /dev/null` ]] && echo "No seismic data found in input dir" && exit

if [[ "$AutoPick" = "True" ]] || [[ "$AutoPick" = "true" ]]; then
	P_Picker
else
	cd $input
	for data in `ls *$SAC`; do
		PSec=`saclst A f $data | awk '{print $2}'` 
		(( `echo "$PSec == -12345" | bc -l` )) && continue
		evtm=`saclst KZTIME f $data | awk '{print $2}'` 
		stnm=`saclst KSTNM f $data | awk '{print $2}'` 		
		Ptme=`date --date "$evtm UTC +$PSec sec" "+%H:%M:%S"`
		echo "$data $PSec $Ptme $stnm" >> P_Arrivals.dat
	done
fi

vel_Reader
Real_Regression
TT_Calculator
[[ "$Dept_Prob" = "True" ]] || [[ "$Dept_Prob" = "true" ]] && Depth_BT
map
